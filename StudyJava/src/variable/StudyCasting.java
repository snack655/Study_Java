package variable;

public class StudyCasting {
    public static void main(String[] args) {
        /** 형변환(캐스팅, casting)이란?
         서로 다른 타입간의 연산을 수행해야 하는 경우?
         이럴 때는 연산을 수행하기 전에 타입을 일치시켜야 한다.
         변수나 리터럴의 타입을 다른 타입으로 변환하는 것일 '형변환(casting)'이라고 한다.
         */

        //------------------------------------------------------------------------------------------
        // 형변환 방법
        // 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.
        // (타입)피연산자

        // 여기에 사용되는 괄호()는 '캐스트 연산자'또는 '형변환 연산자'라고 하며,
        // 형변환을 '캐스팅(casting)'이라고도 한다.
        double d = 85.4;
        int score = (int)d;  // double 타입의 변수 d를 int 타입으로 형변환
        // 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.
        System.out.println("score=" + score);
        System.out.println("d=" + d);

        // 기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능!
        // 기본형과 참조형간의 형변환은 불가능하다.

        // float -> int 에서 소수점 이하의 값은 반올림이 아닌 버림으로 처리한다.

        //------------------------------------------------------------------------------------------
        /**
         서로 다른 타입간의 대입이나 연산을 할 때,
         형변환으로 타입을 일치시키는 것이 원칙이다.

         하지만, 경우에 따라 편의산의 이유로 형변환을 생략할 수 있다.
         그렇다고 해서 형변환이 이루어지지 않는 것은 아니고,
         컴파일러가 생략된 형변환을 자동적으로 추가한다.

         float f = 1234;    // 형변환 생략. float f = (float)1234; 와 같다.

         우변은 int 타입의 상수이고, 이 값을 저장하려는 변수 타입은 float 이다.
         서로 타입이 달라서 형변환이 필요하지만 편의상 생략하였다.
         float 타입의 변수는 1234라는 값을 저장하는데 아무런 문제가 없기 때문이다.

         그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생!
         byte b = 1000;

         명시적으로 형변환 해줬을 경우, 에러가 발생하지 않는다.
         char ch = (char)1000;

         다음과 같은 계산식에서 자주 형변환이 생략되는데,
         서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 다음에 연산을 수행해야 하므로,
         연산과정에서 형변환이 자동적으로 이루어진다.
         int i = 3;
         double d = 1.0 + i;    // double d = 1.0 + (double)i; 에서 형변환이 생략
         사로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨다.

         이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다.

         ----------------------------------------------------------------------------
         자동 형변환의 규칙
         컴파일러는 어떤 판단 기준으로 타입을 일치시킬까?

         > 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.

         byte -> short -> int -> long -> float -> double
                  char -^

         char 과 short 는 어느쪽으로든 값 손실이 발생할 수 있어서 자동 형변환이 불가능하다.

         < 정리 > ------------------------------------------------
         1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
         2. 기본형과 참조형은 서로 형변환할 수 없다.
         3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
            값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
         */

    }
}
